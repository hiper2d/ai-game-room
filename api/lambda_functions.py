import concurrent.futures
import textwrap
import uuid
from typing import List

from dotenv import load_dotenv, find_dotenv

from api.ai.assistants import ArbiterAssistantDecorator, PlayerAssistantDecorator
from api.models import Player, Game
from api.player_generator import generate_players
from api.redis.redis_helper import connect_to_redis, save_game_to_redis, load_game_from_redis, \
    add_player_message_to_redis_list, delete_redis_game_history_list


def init_game():
    load_dotenv(find_dotenv())

    game_scene = textwrap.dedent(  # todo: this text has to be generated by AI
        """In the heart of a bustling mid-west saloon, the air filled with the sound of piano tunes and clinking, \
        glasses a diverse group of individuals finds shelter from a howling snowstorm. Each person, a stranger to the \
        next, carries a story colored by the trials of the Wild West. As the fire crackles in the hearth and the storm \
        rages on, unseen tensions and hidden tales weave a tapestry of intrigue and suspense."""
    )
    print("\nGame Scene:")
    print(game_scene)

    all_players: List[Player] = generate_players()
    for current_player in all_players:
        print(current_player)

        players_names_and_stories = ""
        for other_player in all_players:
            if other_player.name != current_player.name:
                players_names_and_stories += f"Name: {other_player.name}\nStory: {other_player.backstory}\n\n"
        players_names_and_stories = players_names_and_stories.strip()

        new_player_assistant = PlayerAssistantDecorator.create_player(
            player=current_player,
            game_story=game_scene,
            players_names_and_stories=players_names_and_stories
        )
        current_player.assistant_id = new_player_assistant.assistant.id
        current_player.thread_id = new_player_assistant.thread.id

    new_arbiter = ArbiterAssistantDecorator.create_arbiter(players=all_players, game_story=game_scene)

    game = Game(
        id=str(uuid.uuid4()),
        story=game_scene,
        players=all_players,
        arbiter_assistant_id=new_arbiter.assistant.id,
        arbiter_thread_id=new_arbiter.thread.id
    )

    r = connect_to_redis()
    save_game_to_redis(r, game)
    return game.id


# Sequential execution is super slow
def get_welcome_messages_from_all_players(game_id: str):
    load_dotenv(find_dotenv())

    r = connect_to_redis()
    game: Game = load_game_from_redis(r, game_id)
    if not game or not game.players:
        print(f"Game with id {game_id} not found in Redis")
        return

    all_introductions = []
    for player in game.players:
        player_assistant = PlayerAssistantDecorator.load_player_by_assistant_id_with_new_thread(
            assistant_id=player.assistant_id, old_thread_id=player.thread_id
        )
        answer = player_assistant.ask("Please introduce yourself to the other players.")
        all_introductions.append(f"{player.name}: {answer}")
    delete_redis_game_history_list(r, game_id)
    add_player_message_to_redis_list(r, game_id, all_introductions)
    return all_introductions


# This function for local testing only. When deployed to AWS Lambda, it should call other lambdas for each player
# rather than using threads
def get_welcome_messages_from_all_players_async(game_id: str):
    load_dotenv(find_dotenv())

    r = connect_to_redis()
    game: Game = load_game_from_redis(r, game_id)
    if not game or not game.players:
        print(f"Game with id {game_id} not found in Redis")
        return

    def get_player_introduction(player):
        player_assistant = PlayerAssistantDecorator.load_player_by_assistant_id_with_new_thread(
            assistant_id=player.assistant_id, old_thread_id=player.thread_id
        )
        answer = player_assistant.ask("Please introduce yourself to the other players.")
        return f"{player.name}: {answer}"

    with concurrent.futures.ThreadPoolExecutor() as executor:
        futures = [executor.submit(get_player_introduction, player) for player in game.players]
        all_introductions = [future.result() for future in concurrent.futures.as_completed(futures)]

    delete_redis_game_history_list(r, game_id)
    add_player_message_to_redis_list(r, game_id, all_introductions)
    return all_introductions


def talk_to_all(game_id: str, user_message: str):
    load_dotenv(find_dotenv())
    r = connect_to_redis()
    game: Game = load_game_from_redis(r, game_id)

    arbiter = ArbiterAssistantDecorator.load_arbiter_by_assistant_id_and_thread_id(
        assistant_id=game.arbiter_assistant_id, thread_id=game.arbiter_thread_id
    )
    # todo: save the user message to Redis List History
    # add_player_message_to_redis_list(r, game_id, f"Alex: {user_message}")
    # todo: add messages from Redis List from the offset to the end
    arbiter.ask(user_message)


def delete_assistants_from_openai(game_id: str):
    load_dotenv(find_dotenv())
    r = connect_to_redis()
    game: Game = load_game_from_redis(r, game_id)

    arbiter = ArbiterAssistantDecorator.load_arbiter_by_assistant_id_and_thread_id(
        assistant_id=game.arbiter_assistant_id, thread_id=game.arbiter_thread_id
    )
    arbiter.delete()
    for player in game.players:
        if player.assistant_id:
            player_assistant = PlayerAssistantDecorator.load_player_by_assistant_id_and_thread_id(
                assistant_id=player.assistant_id, thread_id=player.thread_id
            )
            player_assistant.delete()
            player.assistant_id = ''
            player.thread_id = ''
